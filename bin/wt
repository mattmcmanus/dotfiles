#!/usr/bin/env bash
set -e

# Switch between git worktrees with speed.

args=("$@")
VERSION="0.1.1"
TMP_PATH=$(mktemp)
BINARY_PATH=$(which wt)

# Escape forward slash
arg=$(echo "${args[0]}" | sed 's/\//\\\//g')

# show worktree list
worktree_list() {
	git worktree list
}

help_message() {
	echo -e "wt lets you switch between your git worktrees with speed.\n"
	echo "Usage:"
	echo -e "\twt <worktree-name>: search for worktree names and change to that directory."
	echo -e "\twt list: list out all the git worktrees."
	echo -e "\twt help: shows this help message."
}

goto_main_worktree() {
	worktree_dir=$(git worktree list --porcelain | grep -E 'worktree ' | awk '{print $0; exit}' | cut -d ' ' -f2-)
	change_worktree
}

# New function to get the relative path from the current worktree root
get_relative_path() {
	current_worktree_root=$(git rev-parse --show-toplevel)
	current_path=$(pwd)
	if [ "$current_worktree_root" = "$current_path" ]; then
		relative_path="."
	else
		relative_path=${current_path#$current_worktree_root/}
	fi
	echo $relative_path
}

# Modified change_worktree function to preserve the current working directory
change_worktree() {
	relative_path=$(get_relative_path)
	echo Changing to worktree at: "$worktree_dir"
	cd "$worktree_dir"
	# Check if the relative path exists in the new worktree and navigate if it does
	if [ -d "$relative_path" ]; then
		cd "$relative_path"
	fi
	# exec $SHELL
}

# Add this function to handle adding a new worktree
add_new_worktree() {
	local name="$1"
	goto_main_worktree
	git worktree add "../$name"
	cd ../$name
	post_add_worktree
}

# Custom code to run after the worktree is created
post_add_worktree() {
	if [ -d "../vscode-defaults" ]; then
		echo "Copying vscode defaults"
		cp ../vscode-defaults/* .vscode/
	fi

	if [ -f ".vscode/extensions.json" ]; then
		echo "Installing extensions"
		jq -r '.recommendations[]' .vscode/extensions.json | while read extension; do
			code --install-extension $extension
		done
	fi

	code .
}

case "${args[0]}" in
list)
	worktree_list
	;;
update)
	update
	;;
help)
	help_message
	;;
version)
	echo Version: $VERSION
	;;
-)
	goto_main_worktree
	;;
add)
	if [ -z "${args[1]}" ]; then
		echo "Error: No name provided for the new worktree."
		exit 1
	else
		add_new_worktree "${args[1]}"
	fi
	;;
*)
	SELECTION=$(git worktree list | sed -r 's/^(.*\/([^[:space:]]* ))/\1 \2/g' | fzf --with-nth=2,4 --height 10 --border --prompt "tree: " --query=$arg)
	if [ "$SELECTION" = "" ]; then
		exit 0
	fi
	worktree_dir=$(cut -d" " -f1 <<<"$SELECTION")
	;;
esac

# If directory variable is not empty then change worktree
if [ -z "$worktree_dir" ]; then
	:
else
	change_worktree
fi
exec $SHELL
